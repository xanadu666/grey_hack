// xtools by xanadu

color = {}
	color.white = "<color=#FFFFFF>"
	color.grey = "<color=#A5A5A5>"
	color.blue = "<color=#003AFF>"
	color.cyan = "<color=#00FFE7>"
	color.purple = "<color=#D700FF>"
	color.red = "<color=#AA0000>"
	color.yellow = "<color=#FBFF00>"
	color.orange = "<color=#FF8701>"
	color.green = "<color=#00ED03>"
	color.cap = "</color>"

// NetInfo function ================================================================================================
NetInfo = function(net_session)
	print("number of connected gateways: " + net_session.get_num_conn_gateway)
	print("number of portforwards: " + net_session.get_num_portforward)
	print("number of users: " + net_session.get_num_users)
	print("any active users?: " + net_session.is_any_active_user)
	print("root active?: " + net_session.is_root_active_user)
end function

// RouterData function ============================================================================================
RouterData = function(ipAddress, port)
	if not port then port = 0
	if typeof(port) == "string" then port = port.to_int
	rdRouter = get_router(ipAddress)
	net_session = metaxploit.net_use(ipAddress, port)
	if rdRouter then
		deviceList = rdRouter.devices_lan_ip
		deviceInfo = "\n\nconnected devices: "
		for device in deviceList
			deviceInfo = deviceInfo + device + "\n                   "
		end for
		print(deviceInfo)
		print("firewall rules: " + rdRouter.firewall_rules)
		if net_session then NetInfo(net_session)
	else
		if net_session then NetInfo(net_session)
	end if
end function

// pending update function for apt-get =============================================================================
PendingUpdating = function(fPath)
	pUpdate = []
	tFolder = get_shell.host_computer.File(fPath)
	if tFolder != null then
		files = tFolder.get_files
		for iFile in files
			output = aptclient.check_upgrade(iFile.path)
			if output == true then
				pUpdate.push(iFile.name)
			end if
		end for
	end if
	return pUpdate
end function

// ls input validation function ====================================================================================
ValidateInput = function(input)
	if input == "-la" or input == "-l" or input == "-a" or input == "-al" then return true
	return false
end function

// search function ===========================================================================================
MEMDUMP = function(fileObject)
	if typeof(fileObject) != "file" then return null
	newList = []
	fileList = fileObject.get_folders + fileObject.get_files
	while fileList.len > 0
		file = fileList.pull
		if file.is_folder then fileList = fileList + file.get_folders + file.get_files
		newList.push(file)
	end while
	return newList
end function

// draw title function ===================================================================================
title = function()
	clear_screen
	print("<color=purple><b>       ______  _____   _____         ____  </color></b>")
	print("<color=purple><b>\\  //   ||   ||   || ||   || ||   //      </color></b>")
	print("<color=purple><b> \\//    ||   ||   || ||   || ||   \\____  </color></b>")
	print("<color=purple><b> //\\    ||   ||   || ||   || ||         \\</color></b>")
	print("<color=purple><b>//  \\   ||   ||___|| ||___|| ||____ ____//</color></b>")
	print("<color=purple>      								by <b>xanadu</b></color>\n\n")
	return
end function

// CAT FUNCTION ================================================================================
CAT = function(input0, obj, input1)
	while true
		if typeof(obj) == "shell" then obj = obj.host_computer
		file = obj.File(input1)
		if file == null then
			print("<b>" + input0 + ": file not found: " + input1)
			break
		end if
		if file.is_binary then
			print("<b>" + input0 + ": can't open." + " " + file.path + " " + " is binary file")
			break
		end if
		if not file.has_permission("r") then
			print("<b>" + input0 + ": permission denied")
			break
		end if
		print(file.get_content)
		break
	end while
end function

// COPY FUNCTION ==================================================================================
COPY = function(input0, input1, input2, obj)
	while true
		oFile = input1
		dFolder = input2
		if typeof(obj) == "shell" then obj = obj.host_computer
		file = obj.File(oFile)
		if not file then
			print("<b>" + input0 + ": can't find" + " " + oFile)
			break
		end if
		nName = ""
		folder = obj.File(dFolder)
		if not folder then
			pathParent = parent_path(dFolder)
			if pathParent == dFolder then
				nName = dFolder
				dFolder = file.parent.path
				output = file.copy(dFolder,nName)
				if output and output != 1 then print(output)
				break
			end if
			folder = obj.File(pathParent)
			nName = dFolder[dFolder.len - (dFolder.len - pathParent.len):]
			if nName[0] == "/" then 
				nName = nName[1:]
			end if
			if not folder then
				print("<b>" + input0 + ": can't copy file." + " " + dFolder + " " + "doesn't exist.")
				break
			end if				
		end if
		if folder then
			if file.parent.path != folder.parent.path or file.name != folder.name then
				fDest = folder.path
				if (nName.len == 0) then
					nName = file.name
				end if
				if not folder.is_folder then
					fDest = file.parent.path
					nName = folder.name
				end if
				output = file.copy(fDest,nName)
				if output and output != 1 then print(output)
			end if
		end if				
		break
	end while
end function

// CORRUPTLOG FUNCTION ================================================================================
CORRUPTLOG = function(input0, obj)
	while true
		if typeof(obj) == "shell" then obj = obj.host_computer
		tFile = obj.touch("/home/guest","system.log")
		if not tFile then
			print("<b>" + input0 + ":</b> unable to create fake log file")
			break
		else	
			file = obj.File("/home/guest/system.log")
		end if
		if not file then
			print("<b>" + input0 + ":</b> unable to find fake log file")
			break
		else
			message = user_input("<color=yellow>leave message: ")
			if message then msg = file.set_content(message)
		end if
		mFile = file.move("/var","system.log")
		if mFile == "permission denied" then
			print("<b>" + input0 + ":</b> permission denied")
			break
		else
			lFile = obj.File("/var/system.log")
		end if
		if not lFile then
			print("<b>" + input0 + ": unable to find fake log file")
			break
		else
			lFile.set_owner("root")
			lFile.set_group("root")
			lFile.chmod("o-w")
			lFile.chmod("g-w")
			print("system.log corrupted")
		end if
		break
	end while
end function

// DECIPHER FUNCTION ============================================================================================
DECIPHER = function(input0, input1, input2, obj)
	GetPassword = function(userPass)
		if userPass.len != 2 then
			if input1 == "-f" then
				print("<b>" + input0 + ": " + file.path + " wrong syntax")
				return
			end if
			if input1 == "-h" then
				print("<b>" + input0 + ": wrong syntax")
				return
			end if
		end if
		password = crypto.decipher(userPass[1])
		return password
	end function

	if input1 == "-f" then
		origFile = input2
		if typeof(obj) == "shell" then obj = obj.host_computer
		file = obj.File(origFile)
		if not file then
			print("<b>" + input0 + ": can't find " + origFile)
			return
		end if
		if file.is_binary then
			print("<b>" + input0 + ": can't read " + origFile + ". Binary file")
			return
		end if
		if not file.has_permission("r") then
			print("<b>" + input0 + ": can't read file. Permission denied")
			return
		end if
		if file.get_content.len == 0 then
			print("<b>" + input0 + ": no users found")
			return
		end if
		lines = file.get_content.split("\n")
		password = null
		if lines.len == 1 then
			userPass = lines[0].split(":")
			password = GetPassword(userPass)
		else
			print("Multiple users found.")
			numLine = 1
			for line in lines
				if line.len > 0 then
					print(numLine + ": " + line)
					numLine = numLine + 1
				end if
			end for
			option = ""
			inputOk = false
			while( not inputOk )
				option = user_input("Select user: ").to_int
				if typeof(option) != "number" or (option < 1 or option > lines.len) then
					print("Invalid input. Type a valid number")
				else 
					inputOk = true
				end if
			end while
			userPass = lines[option - 1].split(":")
			print("Selected user: " + userPass[0] + "\nDeciphering...")
			password = GetPassword(userPass)
		end if
	end if
	if input1 == "-h" then
		hash = input2.split(":")
		password = GetPassword(hash)
		if password == null then return
	end if
	if not password then
		print("<b>" + input0 + ": Can't find password")
		return
	end if
	print("<b>" + input0 + ": password found! => " + password)
end function

// GETPERMS FUNCTION =========================================================================================
GETPERMS = function(obj)
	if typeof(obj) == "shell" then rhost = obj.host_computer
	if typeof(obj) == "computer" then rhost = obj
	log = rhost.File("/var/system.log")	
	var = rhost.File("/var")
	guest = rhost.File("/home/guest")
	passwd = rhost.File("/etc/passwd")
	etc = rhost.File("/etc")
	fileList = []
	if log then
		fileList.push(log)
	else
		print("<b><color=yellow>/var/system.log not found")
	end if
	if var then fileList.push(var) 
	if passwd then fileList.push(passwd)
	if etc then fileList.push(etc)
	if guest then fileList.push(guest)
	writes = ""
	reads = ""
	for file in fileList
		if file.has_permission("w") then write = "<b><color=green>granted</color></b>"
		if not file.has_permission("w") then write = "<b><color=red>denied</color></b>"
		if file.has_permission("r") then read = "<b><color=green>granted</color></b>"
		if not file.has_permission("r") then read = "<b><color=red>denied</color></b>"
		writes = writes+"<b><color=white>"+file.path+"</b></color>"+" "+write+"\n"
		reads = reads+"<b><color=white>"+file.path+"</b></color>"+" "+read+"\n"
	end for
	print("<b><color=yellow>write permissions\n--------------------------\n"+format_columns(writes)+"\n\n<b><color=yellow>read permissions\n--------------------------\n"+format_columns(reads))
end function

// ESC FUNCTION =============================================================================================
ESC = function(input0, comp)
	breakswitch = 0
	folder = comp.File("/lib")
	if not folder then
		print("<b>" + input0 + ": unable to access /lib")
		return
	else
		libList = folder.get_files
		if not libList then
			print("<b>" + input0 + ": lib files not found")
			return	
		else	
			for lib in libList
				if breakswitch == 1 then break
				metalib = metaxploit.load("/lib" + "/" + lib.name)
				if not metalib then continue
				memList = metaxploit.scan(metalib)
				if not memList then continue
				for mem in memList
					if breakswitch == 1 then break
					itemList = metaxploit.scan_address(metalib, mem).split("Unsafe check: ")
					if not itemList then continue
					for item in itemList
						if item == itemList[0] then continue
						value = item[item.indexOf("<b>")+3:item.indexOf("</b>")]
						result = metalib.overflow(mem, value)
						if typeof(result) == "shell" or typeof(result) == "computer" then
							GETPERMS(result)
							msg = null
							while msg != "yes" and msg != "y" and msg != "n" and msg != "no" and msg != "q"
								msg = user_input("<color=orange><b>escalate privileges with this object?(y/n) or go back to xtools?(q): </color>")
							end while
							if msg == "y" or msg == "yes" then
								outer.lObject = result
								print("<b><color=orange>privilages escalated")
								msg = null
								while msg != "yes" and msg != "y" and msg != "n" and msg != "no"
									msg = user_input("<b><color=orange>go back to xtools with new object?(y/n): ")
								end while
								if msg == "yes" or msg == "y" then
									breakswitch = 1
									break
								end if
							end if
							if msg == "q" then
								breakswitch = 1
								break
							end if
							
						else
							continue
						end if
					end for
				end for
			end for
		end if
	end if
end function

// KILL FUNCTION =======================================================================================
KILL = function(input0, input1, obj)
	while true
		if typeof(obj) == "shell" then obj = obj.host_computer
		PID = input1.to_int
		if typeof(PID) != "number" then
			print("<b>" + input0 + ": The PID must be a number")
			break
		end if
		output = obj.close_program(PID)
		if output == true then 
			print("Process " + PID + " closed")
		else
			print("Process " + PID + " not found")
		end if
		break
	end while
end function

// LAUNCHPROBE FUNCTION==============================================================================
LAUNCHPROBE = function(prams0,prams1,prams2,myShell,myComp)
	clear_screen
	print("\n\n\n\n"+color.grey+"<b>launchprobe"+color.white+" ---"+color.yellow+"---"+color.orange+"---"+color.red+"-->"+color.yellow+"/\")
	print(color.cyan+"  by xanadu<b> <---"+color.blue+"----"+color.purple+"---"+color.red+"--"+color.yellow+"\/\n\n\n\n")
	prams = []
	prams.push(prams0)
	if prams1 then prams.push(prams1)
	if prams2 then prams.push(prams2)
	if prams.len == 2 then searchTerm = prams1
	if prams.len == 2 and prams1 == "-r" then searchTerm = "" 
	if prams.len == 3 and prams1 == "-r" then searchTerm = prams1
	ip = prams0
	if not is_valid_ip(ip) then
		print(color.orange+"<b>launchprobe: error: ip is invalid")
		return
	end if
	router = get_router(ip)
	if not router then
		print(color.orange+"<b>launchprobe: error: unable to connect to router")
		return
	end if
	ports = router.used_ports
	if not ports then
		print(color.orange+"<b>launchprobe: error: no open ports detected")
		return
	end if
	for port in ports
		if port.is_closed then continue
		portnumber = port.port_number
		if typeof(portnumber) != "number" then continue
		if prams.len == 2 and prams1 == "-r" then portnumber = 0
		net_session = metaxploit.net_use(ip,portnumber)
		if not net_session then continue
		metalib = net_session.dump_lib	
		if not metalib then continue
		mems = metaxploit.scan(metalib)
		if not mems then continue
		for mem in mems
			unsecVals = metaxploit.scan_address(metalib,mem).split("Unsafe check: ")
			if not unsecVals then continue
			for unsecVal in unsecVals
				value = unsecVal[unsecVal.indexOf("<b>")+3:unsecVal.indexOf("</b>")]
				if not value then continue
				obj = metalib.overflow(mem,value)
				if not obj then continue
				if typeof(obj) == "shell" then	
					print(color.yellow+typeof(obj))
					GETPERMS(obj)
					useobj = ""
					while useobj != "y" and useobj != "n"
						useobj = user_input("<b><color=yellow>use this shell to launch probe?(y/n): ")	
					end while
					if useobj == "n" then continue
					if useobj == "y" then
						log = obj.host_computer.File("/var/system.log")
						var = obj.host_computer.File("/var")					
						if log.has_permission("w") and var.has_permission("w") then
							print(color.yellow+"attempting to clear logs")
							dellog = log.delete
							if not dellog then
								print("logs cleared")
							else
								print(dellog)
							end if
						end if
						clear_screen
						print(color.cyan+"<b>launching probe towards target network: "+color.orange+ip)
						wait(3)
						myShell.scp("/root/packet","/home/guest",obj)
						uploadCheck = obj.host_computer.File("/home/guest/packet")
						if uploadCheck then print(color.cyan+"probe has landed in target network: "+color.orange+ip)
						print(color.cyan+"<b>probe deployed")
						wait(3)
						if uploadCheck and (prams.len == 2 or prams.len == 3) then
							obj.launch("/home/guest/packet/probe",searchTerm)
						else
							obj.launch("/home/guest/packet/probe")
						end if
						obj.scp("/home/guest/packet/package","/root/Downloads",myShell)
						downloadCheck = myComp.File("/root/Downloads/package")
						if downloadCheck then
							print(color.cyan+"<b>package downloaded to /root/Downloads")
						else
							print(color.orange+"<b>launchprobe: error: unable to download package")		
						end if
						uploadCheck.delete
						deleteCheck = obj.host_computer.File("/guest/packet")
						if not deleteCheck then print(color.cyan+"<b>packet removed from remote target")
						if deleteCheck then print(color.orange+"<b>launchprobe: error: failed to remove packet from remote target")
				
						if var.has_permission("w") then
							input2 = ""
							while input2 != "y" and input2 != "yes" and input2 != "n" and input2 != "no"
								input2 = user_input(color.cyan+"corrupt log file?(y/n): ")
							end while
							if input2 == "y" or input2 == "yes" then
								tfile = obj.host_computer.touch("/guest","a8erhg09")
								if tfile == true then
									fakelog = obj.host_computer.File("/guest/a8erhg09")
									if fakelog then
										movefile = fakelog.move("/var","system.log")
										fakelog = obj.host_computer.File("/var/system.log")
										if not fakelog.is_binary then
											print("log file corrupted")
											leavenote = ""
											while leavenote != "y" and leavenote != "n"
												leavenote = user_input(color.cyan+"leave a message?(y/n): ")
											end while
											if leavenote == "y" then
												message = user_input(color.cyan+"enter message: ")
												fakelog.set_content(message)
												print(color.cyan+"<b>message saved to system.log")
											end if
										else
											print("failed to corrupt log file")
										end if
									else
										print("unable to find fake log file")
									end if
								else
									print("unable to create fake log file")
								end if
							end if
						end if
						if downloadCheck then
							print(color.cyan+"<b>check in /root/Downloads for package")
							return
						end if
						return
					end if
				end if
			end for
		end for
	end for
end function	


// RM FUNCTION ======================================================================================
RM = function(input0, input1, input2, obj)
	while true
		if typeof(obj) == "shell" then obj = obj.host_computer
		pathFile = input1
		isRecursive = 0
		if input1 == "-r" then
			isRecursive = 1
			pathFile = input2
		end if	
		file = obj.File(pathFile)
		if file then fileName = file.name
		if file == null then
			print("<b>" + input0 + ": file not found: " + pathFile)
			break
		end if
		if not file.has_permission("w") then
			print("<b>" + input0 + ": permission denied")
			break
		end if
		if file.is_folder == 1 and isRecursive == 0 then
			print("<b>" + input0 + ": " + file.name + " is a directory")
		else
			output = file.delete
			if output.len > 0 then print(output)
			check = obj.File(pathFile)
			if not check then print("<b>" + input0 + ": " + fileName + " deleted successfully")
		end if
		break
	end while
end function

// SCAN FUNCTION ===================================================================================
SCAN = function(input0, input1, input2, comp)
	while true
		if input1 == "-l" then
			file = comp.File(input2)
			if not file then
				print("<b>" + input0 + ": unable to find " + input2)
				break
			else	
				metalib = metaxploit.load(input2)
			end if
		else
			if not is_valid_ip(input1) then
				print("<b>" + input0 + ": invalid ip address")
				break
			end if
			scanAddress = input1
			scanPort = input2.to_int
			targRouter = get_router(scanAddress)
			if targRouter then 
				targPort = targRouter.ping_port(scanPort)
				if scanPort != 0 then
					if not targPort then
						print("<b>" + input0 + ": target port is closed or does not exist")
						break
					end if
				end if
			end if
			if scanPort isa "string" then
				print("<b>" + input0 + ": invalid port")
				break
			end if
			scan_net_session = metaxploit.net_use(scanAddress,scanPort)
			if not scan_net_session then
				print("<b>" + input0 + ": net session failed")
				break
			end if		
			metalib = scan_net_session.dump_lib
		end if	
		memList = metaxploit.scan(metalib)
		shellFlag = 0
		fileFlag = 0
		compFlag = 0
		i = 1
		for mem in memList
			scanResults = metaxploit.scan_address(metalib,mem).split("Unsafe check: ")
			for result in scanResults
				while result != scanResults[0]
					value = result[result.indexOf("<b>")+3:result.indexOf("</b>")]
					print("\n\n\n<b><color=orange>" + mem + " " + value)
					obj = metalib.overflow(mem,value)
					if obj then print("<b>object obtainable: <color=yellow>" + obj+"\n")
					if typeof(obj) == "shell" then shellFlag = shellFlag + 1
					if typeof(obj) == "file" then fileFlag = fileFlag + 1
					if typeof(obj) == "computer" then compFlag = compFlag + 1
					if typeof(obj) == "shell" or typeof(obj) == "computer" then GETPERMS(obj)
					i = i + 1
					break
				end while
			end for
		end for
		if input1 == "-l" then
			print("<b><color=yellow>lib file: </color><color=white>" + metalib.lib_name + " " + metalib.version)
			print("<b><color=yellow>local system: </color><color=orange>" + comp.get_name + "		</color><color=yellow>public ip: </color><color=orange>" + comp.public_ip + "		</color><color=yellow> lan ip: </color><color=orange>" + comp.local_ip)
		else
			RouterData(scanAddress,scanPort)
			print("<b><color=yellow>lib file: </color><color=white>" + metalib.lib_name + " " + metalib.version)
			print("<b><color=yellow>remote system ip: </color><color=orange>" + scanAddress + " 		</color><color=yellow>port: </color><color=orange>" + scanPort) 
		end if	
		print("<color=orange>computers: " + compFlag)
		print("<color=orange>files: " + fileFlag)
		print("<color=orange>shells: " + shellFlag)	
		break
	end while
end function

// SEARCH FUNCTION ================================================================================
SEARCH = function(input1, obj)
	if typeof(obj) == "shell" then obj = obj.host_computer
	file = obj.File("/")
	sList = MEMDUMP(file)
	for item in sList
		if input.len == 2 then
			index = indexOf(item.name, input1)
			index2 = indexOf(item.path, input1)
			if index or index2 or item.name == input1 then print(item.path)
		else
			print(item.path)
		end if
	end for
end function

SECURE = function()
	print("<b><color=orange>secure: secures machine and makes xtools the only way to access system\n<b><color=orange>all desktop icons will be disabled and all commands must be entered in Terminal.exe and or xtools\n<b><color=orange>all files in bin will be backed up and /bin folder will be cleared except for cd and xtools")
	if active_user != "root" then exit("<b><color=yellow>secure: not root user. must have administrative privilages.  use sudo -s to login as root user.")
	myComp = get_shell.host_computer
	xtoolsRoot = myComp.File("/root/xtools")
	if not xtoolsRoot then exit("<b><color=yellow>secure: cant find /root/xtools. make sure newest version of xtools installed in /root")
	input = ""
	while input != "y" and input != "yes" and input != "n" and input != "no"
		input = user_input("<color=orange>secure machine?(y/n): ")
	end while 
	if input == "y" or input == "yes" then
		xtoolsInitd = myComp.File("/etc/init.d/xtools")
		if not xtoolsInitd then 
			print("<color=orange>copying xtools to /etc/init.d")
			xtoolsRoot.copy("/etc/init.d","xtools") 	
		else
			xtoolsInitd.delete
			print("<color=orange>replacing /etc/init.d/xtools with /root/xtools")
			xtoolsRoot.copy("/etc/init.d","xtools")
		end if
		xtoolsInitd = myComp.File("/etc/init.d/xtools")
		if not xtoolsInitd then exit("<b><yellow>secure: unable to complete process")
		binFolder = myComp.File("/bin")
		if binFolder then
			print("<color=orange>backing up /bin and saving in /root")
			binFolder.copy("/root","binBackUp")
			binFileList = binFolder.get_files
			binFolderList = binFolder.get_folders
			binItems = binFileList + binFolderList
			print("<color=orange>deleting files in /bin")
			if binItems then
				for item in binItems
					if item.name == "cd" then continue
					item.delete
				end for
			end if
		end if	
		print("<color=orange>copying xtools to /bin")
		xtoolsRoot.copy("/bin","xtools")
		print("<color=orange>setting file owner to root for all files")
		print("<color=orange>removing all groups except root")
		print("<color=orange>chmodding file system")
		home = myComp.File("/home")
		users = home.get_folders
		for user in users
			user = user.name
			if user == "guest" then continue
			myComp.delete_group(user,user)
		end for
		owner = myComp.File("/").set_owner("root",true)
		group = myComp.File("/").set_group("root",true)
		myComp.File("/").chmod("u-rwx",true)
		myComp.File("/").chmod("g-rwx",true)
		myComp.File("/").chmod("o-rwx",true)
		myComp.File("/usr/bin/Terminal.exe").chmod("g+x")
		myComp.File("/etc/init.d").chmod("g+x")
		myComp.File("/etc/init.d/xtools").chmod("g+x")
		myComp.File("/bin/xtools").chmod("g+x")
		myComp.File("/root/xtools").chmod("g+x")
		print("<b><color=orange>machine secured")
	else
		print("<b><color=orange>secure: secure aborted")
	end if
end function

// TERMINAL FUNCTION ==============================================================================
TERMINAL = function(input0, obj)
	if typeof(obj) == "shell" then
		msg = user_input("<color=yellow>Open terminal on remote machine?(y/n): ")
	else
		msg = user_input("<color=yellow>Open terminal on local machine?(y/n): ")
	end if
	if msg == "y" or msg == "yes" then obj.start_terminal
end function

// TOUCH FUNCTION =================================================================================
TOUCH = function(input0, input1, obj)
	while true
		if typeof(obj) == "shell" then obj = obj.host_computer
		pFile = input1
		pParent = parent_path(pFile)
		if pParent == pFile then
			pParent = current_path
		end if
		tParent = obj.File(pParent)
		if not tParent then
			print("<b>" + input0 + ": " + pParent + " not found")
			break
		end if
		if not tParent.has_permission("w") then
			print("<b>" + input0 + ": permission denied")
			break
		end if
		aPath = pFile.split("/")
		output = obj.touch(tParent.path, aPath[aPath.len - 1])
		if output and output != 1 then
			print("<b>" + input0 + ": the file already exists")
			break
		end if
		if output == 1 then print("<b>New file " + input1 + " created.")
		if output == 1 then msg = user_input("Leave message: ")
		if msg then 
			mFile = obj.File(input1)
			mFile.set_content(msg)
		end if
		break
	end while
end function

// XSCRAPE FUNCTION =================================================================================
XSCRAPE = function(input0, input1, input2, input3, obj)
	GetPassword = function(userPass)
		if userPass.len != 2 then
			print("<b>" + input0 + ": wrong syntax")
			return
		end if
		password = crypto.decipher(userPass[1])
		return password
	end function
	success = function(userFolders)
		for userFolder in userFolders
			bankFile = comp.File("/home/" + userFolder.name + "/Config/Bank.txt")
			if not bankFile then continue
			userPass = bankFile.get_content.split(":")
			print("Deciphering bank password for user: " + userFolder.name)
			bankPass = GetPassword(userPass)
			data = file.get_content
			file.set_content(data + userPass[0] + "," + bankPass + ",")
			outer.successes = outer.successes + 1
		end for
	end function
	clear_screen
	ipStart = input1
	fileName = input3
	successes = 0
	if is_valid_ip(ipStart) != true then
		print("<b>" + input0 + ": invalid ip address")
		return
	end if
	ipStartList = ipStart.split("\.")
	w = ipStartList[0].to_int
	x = ipStartList[1].to_int
	y = ipStartList[2].to_int
	z = ipStartList[3].to_int
	a = 256 - z
	b = 256 - y
	c = 256 - x
	//index = 0
	limit = input2.to_int
	if typeof(obj) == "shell" then obj = obj.host_computer
	file = obj.File(current_path + "/" + fileName)
	if file == null then 
		obj.touch(current_path, fileName)
		file = obj.File(current_path + "/" + fileName)
	end if
	for i in range(1,256)
		for j in range(1,c)
			for k in range(1,b)
				for l in range(1,a)
					ip = w + "." + x +"." + y + "." + z
					//index = index + 1
					router = get_router(ip)
					if typeof(router) != "router" then
						z = z + 1
						if z == 256 then z = 0
						continue
					end if
					ports = router.used_ports
					if ports.len == 0 then
						z = z + 1
						if z == 256 then z = 0
						continue
					end if
					print(ip)
					lastLanIP = null
					for port in ports
						portNumber = port.port_number
						lanIP = port.get_lan_ip
						if lanIP == lastLanIP and breakSwitch == "on" then continue
						print(portNumber + " : " + lanIP)
						netsession = metaxploit.net_use(ip, portNumber)
						if typeof(netsession) != "NetSession" then continue
						metaLib = netsession.dump_lib
						print("Scanning " + metaLib.lib_name + " " + metaLib.version )
						listMem = metaxploit.scan(metaLib)
						if listMem.len == 0 then continue
						print("Scan completed: detected vulnerabilities in " + listMem.len + " memory zones.  Beginning attack.")
						for itemMem in listMem
							print(itemMem)
						end for
						userFolders = null
						breakSwitch = "off"
						for itemMem in listMem
							vulnMem = metaxploit.scan_address( metaLib, itemMem ).split("Unsafe check: ")
							if breakSwitch == "on" then break
							for wordMem in vulnMem
								if wordMem == vulnMem[0] then continue
								if userFolders then 
									success(userFolders)
									breakSwitch = "on"
									lastLanIP = lanIP[0:]
									if successes == limit then
									//if index == limit then
										print("<b>" + input0 + ": scraper finished")
										return null
									end if
									break
								end if
								value = wordMem[wordMem.indexOf("<b>")+3:wordMem.indexOf("</b>")]
								result = metaLib.overflow(itemMem, value)
								if typeof(result) == "computer" or typeof(result) == "shell" then
									if typeof(result) == "shell" then comp = result.host_computer
									if typeof(result) == "computer" then comp = result
									if not userFolders then homeFolders = comp.File("/home")
									userFolders = homeFolders.get_folders
								//else
									//if index == limit then
										//print("<b>" + input0 + ": scraper finished")
										//return null
									//end if
									//continue
								end if
							end for
						end for	
					end for
					z = z + 1
					if z == 256 then z = 0
				end for
				a = 256
				y = y + 1
				if y == 256 then y = 0	
			end for	
			b = 256
			x = x + 1
			if x == 256 then x = 0
		end for
		c = 256
		w = w + 1
	end for
end function

// get libs =========================================================================================
metaxploit = include_lib("/lib/metaxploit.so")
if not metaxploit then metaxploit = include_lib(current_path + "/metaxploit.so")
if not metaxploit then exit("<b>xtools: missing metaxploit.so")
crypto = include_lib("/lib/crypto.so")
if not crypto then crypto = include_lib(current_path + "/crypto.so")
if not crypto then exit("<b>xtools: missing crypto.so")
aptclient = include_lib("/lib/aptclient.so")
if not aptclient then aptclient = include_lib(current_path + "/aptclent.so")
if not aptclient then exit("<b>xtools: missing aptclient.so")

// initialize globals
myShell = get_shell
myComp = myShell.host_computer
aptGetMessage = "<b>Usage: apt-get install [program name]\n<b>Usage: apt-get search [program name]\n<b>Usage: apt-get show [repo ip address]\n<b>Usage: apt-get addrepo [repo ip address]\n<b>Usage: apt-get delrepo [repo ip address]\n<b>Usage: apt-get update\n<b>Usage: apt-get upgrade"
object = null
lObject = null
cCheck = 0

// display title ====================================================================================
title

// main program loop ====================================================================================


pcode = user_input("<color=blue><b>enter access code: </b></color>",true)

print("<b>type help for commands")
print("<b><color=yellow>launch binary files with ./")
while pcode == "xtools"
	if lObject and typeof(lObject) == "shell" then
		myShell = lObject
		myComp = lObject.host_computer
		print("\n\n<color=white><b>holding local shell object:\n<color=white><b>local sysem commands may have gained or lost privilages.\n<color=white><b>use terminal command to open new terminal\n<color=white><b>as owner of local shell object")
	end if
	if lObject and typeof(lObject) == "computer" then
		myComp = lObject
		print("\n\n<color=white><b>holding local computer object: local commands may have gained or lost privilages")
	end if
	if object and typeof(object) == "shell" then print("\n\n<color=orange><b>holding: </color><color=yellow>" + object + "</color><color=orange> belonging to system: </color><color=yellow>" + object.host_computer.get_name + "\n<b><color=orange>public ip: </color><color=yellow>" + object.host_computer.public_ip + "</color><color=orange> lan ip: </color><color=yellow>" + object.host_computer.local_ip)
	if object and typeof(object) == "computer" then print("\n\n<color=orange><b>holding: </color><color=yellow>" + object + "</color><color=orange> belonging to system: </color><color=yellow>" + object.get_name + "\n<b><color=orange>public ip: </color><color=yellow>" + object.public_ip + "</color><color=orange> lan ip: </color><color=yellow>" + object.local_ip)
	if object and typeof(object) == "file" then print("<\n\n(color=orange><b>holding: </color><color=yellow>" + object + "</color><color=orange> named: </color><color=yellow>" + object.name)
	cCheck = 0
	input = user_input("<color=orange><b>" + active_user + "@" + current_path + "----></b></color>").split(" ")	
	
// ./ =============================================================================================================================
	
	if input[0][:2] == "./" then cCheck = 1
	if input[0][:2] == "./" and input[0].len == 2 then print("<b>Usage: ./[binary file path]")
	if input[0][:2] == "./" and input[0].len > 2 then
		launchFile = myComp.File(input[0][2:])
		if launchFile then
			if launchFile.is_binary then
				if input.len > 1 then myShell.launch(launchFile.path, input[1:].join(" "))
				if input.len == 1 then myShell.launch(launchFile.path)
			else
				print("<b>xtools: ./: "+input[0][2:]+" is not a binary file")
			end if
		else
			print("<b>xtools: ./: binary file "+input[0][2:]+" not found")
		end if
	end if

// aircrack ========================================================================================================================
	if input[0] == "aircrack" then cCheck = 1
	if input[0] == "aircrack" and input.len != 2 then print("<b>Usage: aircrack [file.cap]")
	if input[0] == "aircrack" and input.len == 2 then
		while true
			crackPathFile = input[1]
			crackFile = myComp.File(crackPathFile)
			if crackFile == null then
				print("<b>aircrack: file not found: " + crackPathFile)
				break
			end if
			if not crackFile.is_binary then
				print("<b>aircrack: Can't process file.  Not valid filecap.")
				break
			end if
			if not crackFile.has_permission("r") then
				print("<b>aircrack: permission denied")
				break
			end if
			crackKey = crypto.aircrack(crackFile.path)
			if crackKey then
				print("KEY FOUND! [" + crackKey + "]")
			else
				print("<b>aircrack: Unable to get the key")
			end if
			break
		end while
	end if

// aireplay ====================================================================================================================
	if input[0] == "aireplay" then cCheck = 1
	if input[0] == "aireplay" and (input.len != 4) then print("<b>Usage: aireplay [bssid] [essid] [max ack's]")
	if input[0] == "aireplay" and input.len == 4 then
		while true
			playBssid = input[1]
			playEssid = input[2]
			maxAck = input[3].to_int
			if maxAck isa string then
				print("<b>Usage: aireplay [bssid] [essid] [max ack's]")
				break
			end if
			playResult = crypto.aireplay(playBssid, playEssid, maxAck)
			if typeof(playResult) == "string" then print(playResult)
			break
		end while
	end if
// airmon =====================================================================================================================
	if input[0] == "airmon" then cCheck = 1
	if input[0] == "airmon" and (input.len > 1 and input.len != 3) then print("<b>Usage: airmon\n<b>Usage: airmon [start:stop] [Net Device]")
	if input[0] == "airmon" and (input.len == 1 or input.len == 3) then
		while true
			formatOutput = "Interface Chipset Monitor_Mode\n"
			if input.len == 1 then
				print(format_columns(formatOutput + myComp.network_devices))
				break
			end if
			airOption = input[1]
			airDevice = input[2]
			if airOption != "start" and airOption != "stop" then
				print("<b>Usage: airmon\n<b>Usage: airmon [start:stop] [Net Device]")
				break
			end if
			airOutput = crypto.airmon(airOption, airDevice)
			if not airOutput then
				print("airmon: " + airDevice + " not found")
				break
			end if
			if typeof(airOutput) == "string" then
				print(airOutput)
				break
			end if
			print(format_columns(formatOutput + myComp.network_devices))
			break
		end while
	end if

// apt-get ==============================================================================================================
	if input[0] == "apt-get" then cCheck = 1
	if (input[0] == "apt-get" and (input.len == 1 or input.len > 4)) or (input[0] == "apt-get" and (input.len == 2 and (input[1] == "install" or input[1] == "search" or input[1] == "show" or input[1] == "addrepo" or input[1] == "delrepo"))) then print(aptGetMessage)
	if (input[0] == "apt-get" and (input.len == 2 and (input[1] == "upgrade" or input[1] == "update"))) or (input[0] == "apt-get" and (input.len == 3 or input.len == 4)) then
		while true
			action = input[1]
			if action == "update" then
				print("Updating pachage lists...")
				aptOutput = aptclient.update
				if aptOutput then print(aptOutput)
			else if action == "install" then
				print("Reading package lists...")
				if input.len != 3 then
					print(aptGetMessage)
					break
				end if
				print("Downloading " + input[2])
				aptOutput = aptclient.install(input[2])
				if aptOutput == true then
					print(input[2] + " installed")
					break
				end if
			else if action == "search" then
				if input.len != 3 then
					print(aptGetMessage)
					break
				end if
				print(aptclient.search(input[2]))
			else if action == "show" then
				if input.len != 3 then
					print(aptGetMessage)
					break
				end if
				print(aptclient.show(input[2]))
			else if action == "addrepo" then
				if input.len < 3 or input.len > 4 then
					print(aptGetMessage)
					break
				end if
				aptPort = 1542
				if input.len == 4 then aptPort = input[3]
				aptOutput = aptclient.add_repo(input[2])
				if aptOutput then
					print(aptOutput)
					break
				end if
			 	print("Repository " + input[2] + " added succesfully.\nLaunch apt with the update option to apply the changes")
			else if action == "delrepo" then
				if input.len != 3 then
					print(aptGetMessage)
					break
				end if
				aptOutput = aptclient.del_repo(input[2])
				if aptOutput then
					print(aptOutput)
					break
				end if
				print("Repository " + input[2] + " removed succesfully.\nLaunch apt with the update option to apply the changes")
			else if action == "upgrade" then
				print("Reading package lists...")
				if input.len == 2 then
					pendingPackages = PendingUpdating("/lib") + PendingUpdating("/bin")
					if pendingPackages.len == 0 then
						print("<b>apt-get: No updates needed")
						break
					end if
					print("The following packages will be updated:")
					pkgs = ""
					for itemPackage in pendingPackages
						pkgs = pkgs + " " + itemPackage
					end for
					print(pkgs)
					aptOption = user_input("\nDo you want to continue?(y/n): ")
					if aptOption == "y" or aptOption == "yes" then
						aptCounter = 0
						for itemPackage in pendingPackages
							aptOutput = aptclient.install(itemPackage)
							if aptOutput == true then
								aptCounter = aptCounter + 1
							else if aptOutput then
								print(aptOutput)
							end if
						end for
						print(aptCounter + " packages updated")
					else
						print("<b>apt-get: aborted")
						break
					end if
				else if input.len == 3 then
					aptOutput = aptclient.check_upgrade(input[2])
					if not aptOutput then
						print("<b>apt-get: No updates needed")
						break
					end if
					if aptOutput == true then
						print("The following package will be updated: " + input[2])
						aptOption = user_input("\nDo you want to continue?(y/n): ")
						if aptOption == "y" or aptOption == "yes" then
							aptOutput = aptclient.install(input[2])
							if aptOutput == true then
								print(input[2] + " installed.")
								break
							end if
							print(aptOutput)
						else
							print("<b>apt-get: aborted")
							break
						end if
					else
						print(aptOutput)
					end if
				end if
			else
				print(aptGetMessage)
			end if
			break
		end while
	end if

// bankscrape =========================================================================================
	if input[0] == "bankscrape" then cCheck = 1
	if input[0] == "bankscrape" and input.len != 4 and input.len != 3 then print("<b>Usage: bankscrape [ip address] [# of accounts] [output file name]\n<b>Usage: bankscrape -l [output file]")
	if input[0] == "bankscrape" and input.len == 4 then XSCRAPE( input[0], input[1], input[2], input[3], myComp)
	if input[0] == "bankscrape" and input.len == 3 and input[1] != "-l" then print("<b>Usage: bankscrape [ip address] [# of accounts] [output file name]\n<b>Usage: bankscrape -l [output file]")
	if input[0] == "bankscrape" and input.len == 3 and input[1] == "-l" then
		while true
			dfileName = input[2]
			data = myComp.File(dfileName)
			if not data then
				print("<b>bankscrape: unable to find output file")
				break
			end if
			file = data.get_content
			fileList = file.split(",")
			i = 0
			clear_screen
			while fileList.len > 2
				if not fileList then break
				if i == 3 then
					contCheck = user_input("press enter to continue. type quit to return to xtools: ")
					breakSwitch = "off"
					if contCheck == "quit" then
						breakSwitch = "on"
						break
					end if
					clear_screen
					i = 0	
				end if
				if i == 0 then print(((fileList.len -1)  / 2) + " items left\n\n")
				info = fileList.pull
				print info
				info = fileList.pull
				print info + "\n\n\n"
				file = fileList.join(",")
				data.set_content(file)
				i = i + 1
				data = get_shell.host_computer.File(dfileName)
				file = data.get_content
				fileList = file.split(",")
			end while
			if breakSwitch == "on" then break
			print("<b>bankscrape: end of list")
			break
		end while
	end if

// build ==============================================================================================
	if input[0] == "build" then cCheck = 1
	if input[0] == "build" and input.len != 3 then print("<b>Usage: build [file source code] [path/program name]")   
	if input[0] == "build" and input.len == 3 then
		while true
			buPathSource = input[1]
			buProgramPath = input[2]
			buFileSource = myComp.File(buPathSource)
			buFolderDest = myComp.File(buProgramPath)
			if buFileSource == null then
				print("<b>build: can't find " + buPathSource)
				break
			end if
			if buFolderDest == null then
				print("<b>build: can't find " + buProgramPath)
				break
			end if
			buOutput = myShell.build(buFileSource.path, buFolderDest.path)
			if buOutput.len == 0 then
				print("<b>build: build successful.")
			else
				print(buOutput)
			end if
			break
		end while
	end if

// cat ==================================================================================================	
	if input[0] == "cat" then cCheck = 1
	if input[0] == "cat" and input.len != 2 then print("<b>Usage: cat [file]")
	if input[0] == "cat" and input.len == 2 then CAT(input[0],myComp,input[1])

// chgrp ====================================================================================================
	if input[0] == "chgrp" then cCheck = 1
	if (input[0] == "chgrp" and (input.len < 3 or input.len > 4)) or (input[0] == "chgrp" and input.len == 4 and input[1] != "-R") or (input[0] == "chgrp" and (input.len == 3 and input[1] == "-R")) then print("<b>Usage: chgrp [opt:-R] [new group] [path file/folder]")
	if (input[0] == "chgrp" and input.len == 3 and input[1] != "-R") or (input[0] == "chgrp" and input.len == 4 and input[1] == "-R") then
		while true
			chgGroup = input[1]
			chgPathFile = input[2]
			chgIsRecursive = 0
			if input.len == 4 then
				chgGroup = input[2]
				chgPathFile = input[3]
				chgIsRecursive = 1
			end if
			chgFile = myComp.File(chgPathFile)
			if chgFile == null then
				print("<b>chgrp: file not found: " + chgPathFile)
				break
			end if
			chgOutput = chgFile.set_group(chgGroup, chgIsRecursive)
			if chgOutput then print(chgOutput)
			break
		end while
	end if

// chmod ==================================================================================================
	if input[0] == "chmod" then cCheck = 1
	if (input[0] == "chmod" and input.len < 3) or (input[0] == "chmod" and input.len == 4 and input[1] != "-R") then print("<b>Usage: chmod [opt:-R] [u,g,o+wrx] [path file/folder]")
	if (input[0] == "chmod" and input.len == 3) or (input[0] == "chmod" and input.len == 4 and input[1] == "-R") then
		while true
			chmPermissions = input[1]
			chmPathFile = input[2]
			chmIsRecursive = 0
			if input.len == 4 then
				chmPermissions = input[2]
				chmPathFile = input[3]
				chmIsRecursive = 1
			end if
			chmFile = myComp.File(chmPathFile)
			if chmFile == null then
				print("<b>chmod: cant't find " + chmPathFile)
				break
			end if
			chmOutput = chmFile.chmod(chmPermissions,chmIsRecursive)
			if chmOutput then print(chmOutput)
			break
		end while
	end if

// chown =================================================================================================
	if input[0] == "chown" then cCheck = 1
	if (input[0] == "chown" and (input.len < 3 or input.len > 4)) or (input[0] == "chown" and input.len == 4 and input[1] != "-R") or (input[0] == "chown" and input.len == 3 and input[1] == "-R") then print("<b>Usage: chown [opt:-R] [owner] [path file/folder]")
	if (input[0] == "chown" and input.len == 3 and input[1] != "-R") or (input[0] == "chown" and input.len == 4 and input[1] == "-R") then
		while true
			choOwner = input[1]
			choPathFile = input[2]
			choIsRecursive = 0
			if input.len == 4 then
				choOwner = input[2]
				choPathFile = input[3]
				choIsRecursive = 1
			end if
			choFile = myComp.File(choPathFile)
			if choFile == null then
				print("<b>chown: file not found: " + choPathFile)
				break
			end if
			choOutput = choFile.set_owner(choOwner, choIsRecursive)
			if choOutput then print(choOutput)
			break
		end while
	end if

// clean ==============================================================================================
	if input[0] == "clean" then cCheck = 1
	if input[0] == "clean" and input.len != 1 then print("<b>Usage: clean")
	if input[0] == "clean" and input.len == 1 then
		trashFolders = myComp.File("/root/.Trash").get_folders
		trashFiles = myComp.File("/root/.Trash").get_files
		trashBag = trashFolders + trashFiles
		for trash in trashBag
			trashItem = myComp.File("/root/.Trash" + "/" + trash.name)
			trashItem.delete
		end for
		print("<b>clean: /root/.Trash emptied")
	end if

// clear ================================================================================================
	if input[0] == "clear" then cCheck = 1
	if input[0] == "clear" and input.len != 1 then print("<b>Usage: clear")
	if input[0] == "clear" and input.len == 1 then clear_screen
	
// corlog =================================================================================================
	if input[0] == "corlog" then cCheck = 1
	if input[0] == "corlog" and input.len != 1 then print("<b>Usage: corlog")
	if input[0] == "corlog" and input.len == 1 then
		logSure = null
		while logSure != "y" and logSure != "yes" and logSure != "n" and logSure != "no"
			logSure = user_input("corrupt system.log?(y/n): ")
		end while
		if logSure == "y" or logSure == "yes" then CORRUPTLOG(input[0], myComp)
		logSure = null
	end if
// cp =======================================================================================================
	if input[0] == "cp" then cCheck = 1
	if input[0] == "cp" and input.len != 3 then print("<b>Usage: cp [path/original file] [path/opt:new name]")
	if input[0] == "cp" and input.len == 3 then COPY(input[0], input[1], input[2], myComp)

// credits =========================================================================================================
	if input[0] == "credits" then cCheck = 1
	if input[0] == "credits" and input.len != 1 then print("<b>Usage: credits")
	if input[0] == "credits" and input.len == 1 then print("xtools developed and coded by:  xanadu\n\n1st beta tester: aldusbumdlebore\n\n2nd beta tester: NoData\n\n3rd beta tester: trialdye\n\n4th beta tester: NightmareGas\n\n<b>special thanks to all involved in the development process\n\n<b>and a very special thanks to my loving wive Missy for not divorcing me for staying up till 3am every night for the past month.")

// decipher ========================================================================================================================
	if input[0] == "decipher" then cCheck = 1
	if input[0] == "decipher" and input.len == 3 and (input[1] == "-h" or input[1] == "-f") then
		DECIPHER(input[0], input[1], input[2], myComp)
	else
		if input[0] == "decipher" then print("<b>Usage: decipher -h [hash]\n<b>Usage: decipher -f [path/file]")
	end if

// drop ==================================================================================================================
	if input[0] == "drop" then cCheck = 1
	if input[0] == "drop" and input.len != 2 then print("<b>Usage: drop [-l:-r]")
	if input[0] == "drop" and input.len == 2 and input[1] != "-r" and input[1] != "-l" then print("<b>Usage: drop [-l:-r]")
	if input[0] == "drop" and input.len == 2 and input[1] == "-r" and not object then print("<b>drop: not holding remote object.")
	if input[0] == "drop" and input.len == 2 and input[1] == "-l" and not lObject then print("<b>drop: not holding local object")
	if input[0] == "drop" and input.len == 2 and ((input[1] == "-r" and object) or (input[1] == "-l" and lObject)) then
		dropObject = null
		if input[1] == "-r" then
			while dropObject != "y" and dropObject != "yes" and dropObject != "n" and dropObject != "no"
				dropObject = user_input("<b><color=yellow>Drop held remote object?(y/n): ")
			end while
			if dropObject == "y" or dropObject == "yes" then object = null
			dropObject = null
		end if
		if input[1] == "-l" then
			while dropObject != "y" and dropObject != "yes" and dropObject != "n" and dropObject != "no"
				dropObject = user_input("<b><color=yellow>Drop held local object?(y/n): ")
			end while
			if dropObject == "y" or dropObject == "yes" then
				lObject = null
				myShell = get_shell
				myComp = myShell.host_computer
			end if
		end if
	end if

// escalate ================================================================================================================
	if input[0] == "escalate" then cCheck = 1
	if input[0] == "escalate" and input.len != 1 then print("<b>Usage: escalate")
	if input[0] == "escalate" and input.len == 1 then ESC(input[0], myComp)

// exit ====================================================================================================================
	if input[0] == "exit" then cCheck = 1
	if input[0] == "exit" and input.len != 1 then print("<b>Usage: exit")
	if input[0] == "exit" and input.len == 1 then exit

// ftp ===================================================================================================================
	if input[0] == "ftp" then cCheck = 1
	if input[0] == "ftp" and (input.len < 3 or input.len > 4) then print("<b>Usage: ftp [user@password] [ip address] [opt:port]")
	if input[0] == "ftp" and (input.len == 3 or input.len == 4) then
		while true
			ftpCredentials = input[1].split("@")
			ftpUser = ftpCredentials[1]
			ftpPassword = ftpCredentials[2]
			ftpPort = 21
			if input.len == 4 then ftpPort = input[3].to_int
			if typeof(ftpPort) != "number" then
				print("<b>ftp: invalid port: " + ftpPort)
				break
			end if
			print("Connecting...")
			ftpShell = get_shell.connect_service(input[2],ftpPort,ftpUser,ftpPassword, "ftp")
			if ftpShell then ftpShell.start_terminal
			break
		end while
	end if	

// grab ==================================================================================================================
	if input[0] == "grab" then cCheck = 1
	if input[0] == "grab" and (input.len < 5 or input.len > 6) then print("<b>Usage: grab [ip address] [port] [memory address] [unsecured value] [opt:arg]\n<b>Usage: grab -l [path/libfile] [unsecured value] [opt:arg]")
	if input[0] == "grab" and (input.len == 5 or input.len == 6) then
		while true
			memAddress = input[3]
			unsVal = input[4]
			if input[1] == "-l" then
				if input.len == 6 then optArg = input[5]
				metalib = metaxploit.load(input[2])
				if not metalib then
					print("<b>grab: metalib not returned")
					break
				end if
			else
				grabAddress = input[1]
				grabPort = input[2].to_int
				if input.len == 6 then optArg = input[5]
				if not is_valid_ip(grabAddress) then
					print("<b>grab: invalid ip address")
					break
				end if
				if grabPort isa "string" then
					print("<b>grab: port not found")
					break
				end if
				grab_net_session = metaxploit.net_use(grabAddress,grabPort)
				if not grab_net_session then
					print("<b>grab: no net session")
					break
				end if
				metalib = grab_net_session.dump_lib
				if not metalib then
					print("<b>grab: metalib not returned")
					break
				end if
			end if
			if input.len == 6 then
				if is_valid_ip(optArg) then
					object = metalib.overflow(memAddress, unsVal, optArg)
				else
					metalib.overflow(memAddress, unsVal, optArg)
				end if
			else
				if input[1] == "-l" then
					lObject = metalib.overflow(memAddress, unsVal)
				else
					object = metalib.overflow(memAddress, unsVal)
				end if
			end if
			break
		end while
	end if

// groupadd ================================================================================================================
	if input[0] == "groupadd" then cCheck = 1
	if input[0] == "groupadd" and input.len != 3 then print("<b>Usage: groupadd [user] [new group]")
	if input[0] == "groupadd" and input.len == 3 then
		while true
			gaddUser = input[1]
			gaddGroup = input[2]
			gaddOutput = myComp.create_group(gaddUser, gaddGroup)
			if gaddOutput == true then
				print("<b>groupadd: group " + gaddGroup + " added to user " + gaddUser)
				break
			end if
			if gaddOutput then
				print(gaddOutput)
				break
			end if
			print("<b>groupadd: the group could not be created")
			break
		end while
	end if

// groupdel ===============================================================================================================
	if input[0] == "groupdel" then cCheck = 1
	if input[0] == "groupdel" and input.len != 3 then print("<b>Usage: groupdel [user] [group]")
	if input[0] == "groupdel" and input.len == 3 then
		while true
			gdelUser = input[1]
			gdelGroup = input[2]
			gdelOutput = myComp.delete_group(gdelUser, gdelGroup)
			if gdelOutput == true then
				print("<b>groupdel: group " + gdelGroup + " deleted from user " + gdelUser)
				break
			end if
			if gdelOutput then
				print(gdelOutput)
				break
			end if
			print("<b>groupdel: the group could not be deleted")
			break
		end while
	end if

// groups ==================================================================================================================
	if input[0] == "groups" then cCheck = 1
	if input[0] == "groups" and input.len != 2 then print("<b>Usage: groups [username]")
	if input[0] == "groups" and input.len == 2 then
		while true
			gpUser = input[1]
			gpOutput = myComp.groups(gpUser)
			if gpOutput == true then 
				print(gpOutput)
				break
			end if
			if gpOutput then print(gpOutput)
			break
		end while
	end if
// ifconfig ==============================================================================================================
	if input[0] == "ifconfig" then cCheck = 1
	if input[0] == "ifconfig" and (input.len != 1 and input.len != 5) then print("<b>Usage: ifconfig \n<b>Usage: ifconfig [net interface] [ip address] gateway [ip address]")
	if input[0] == "ifconfig" and (input.len ==1 or input.len == 5) then
		while true
			if input.len == 1 then
				myRouter = get_router
					if myComp.is_network_active then 
					lip = myComp.local_ip
					pip = myRouter.public_ip
					gw = myComp.network_gateway
					if myComp.active_net_card == "WIFI" then
						ifOutput = "\nConnected to WI-FI:\nEssid: " + myRouter.essid_name + "\nBssid: " + myRouter.bssid_name 
					else
						ifOutput = "\nEthernet connection:"
					end if
				else
					lip = "0.0.0.0"
					pip = "0.0.0.0"
					gw = "0.0.0.0"
					ifOutput = "\nNot connected to the network."
				end if
				print(ifOutput + "\n----------------\nPublic IP: " + pip + "\nLocal IP: " + lip + "\nGateway: " + gw + "\n")
			else
				if input[3] != "gateway" then
					print("<b>Usage: ifconfig \n<b>Usage: ifconfig [net interface] [ip address] gateway [ip address]")
					break
				end if
				ifDevice = input[1]
				ifAddress = input[2]
				ifGateway = input[4]
				if not is_valid_ip(ifAddress) then
					print("<b>ifconfig: invalid ip address")
					break
				end if
				if not is_valid_ip(ifGateway) then
					print("<b>ifconfig: invalid gateway")
					break
				end if
				ifOutput = myComp.connect_ethernet(ifDevice,ifAddress,ifGateway)
				if ifOutput > 0 then
					print(ifOutput)
				else
					print("<b>ifconfig: unable to connect to " + ifAddress)
				end if
			end if
			break
		end while
	end if

// iwconfig =====================================================================================================
	if input[0] == "iwconfig" then cCheck = 1
	if input[0] == "iwconfig" and input.len != 5 then print("<b>Usage: iwconfig [net device] [bssid] [essid name] [pass key]")
	if input[0] == "iwconfig" and input.len == 5 then
		while true

			if myComp.network_devices == null or myComp.network_devices.indexOf(input[1]) == null then
				print("<b>iwconfig: Network device not found")
				break
			end if
			iwBssid = input[2]
			iwEssid = input[3]
			iwPassword = input[4]
			iwStatus = myComp.connect_wifi(input[1],iwBssid,iwEssid,iwPassword)
			if typeof(iwStatus) == "string" then print(iwStatus)
			break
		end while
	end if

// iwlist =============================================================================================================
	if input[0] == "iwlist" then cCheck = 1
	if input[0] == "iwlist" and input.len != 2 then print("<b>Usage: iwlist [net device]")
	if input[0] == "iwlist" and input.len == 2 then
		while true
			if myComp.network_devices == null or myComp.network_devices.indexOf(input[1]) == null then
				print("<b>iwlist: network device not found")
				break
			end if
			if input[1].indexOf("eth") != null then
				print("<b>iwlist: ethernet cards not supported by this command")
				break
			end if
			iwlNetworks = myComp.wifi_networks(input[1])
			if iwlNetworks == null then
				print("<b>Usage: iwlist [net device]")
				break
			end if
			iwlInfo = "BSSID PWR ESSID"
			for network in iwlNetworks
				iwlInfo = iwlInfo + "\n" + network
			end for
			print(format_columns(iwlInfo))
			break
		end while
	end if

// kill ============================================================================================================================
	if input[0] == "kill" then cCheck = 1
	if input[0] == "kill" and input.len != 2 then print("<b>Usage: kill [PID]")
	if input[0] == "kill" and input.len == 2 then KILL(input[0], input[1], myComp)
		
// launchprobe ========================================================================================================================
	if input[0] == "launchprobe" then cCheck = 1
	if input[0] == "launchprobe" and (input.len < 2 or input.len > 4) then print(color.yellow+"<b>Usage: launchprobe [ip address] [opt: -r] [opt: search term]\n"+color.yellow+"if you run into any data dumps that are too \n"+color.yellow+"big to save use optional search term argument\n"+color.yellow+"use optional -r to launch at router_kernel")
	if input[0] == "launchprobe" and input.len == 2 then LAUNCHPROBE(input[1],null,null,myShell,myComp)
	if input[0] == "launchprobe" and input.len == 3 then LAUNCHPROBE(input[1],input[2],null,myShell,myComp)

// ls ======================================================================================================================================
	if input[0] == "ls" then cCheck = 1
	if (input[0] == "ls" and input.len > 4) or (input[0] == "ls" and (input.len == 2 and input[1].indexOf("-") != null and not ValidateInput(input[1]))) or (input[0] == "ls" and (input.len == 3 and not ValidateInput(input[1]))) or (input[0] == "ls" and (input.len == 4 and (not ValidateInput(input[1]) or not ValidateInput(input[2])))) then
		print("<b>Usage: ls [opt:-l, -a, -la, -al] [opt:path]")
	else if input[0] == "ls" then
		lsFolderPath = current_path
		if input[0] == "ls" and input.len > 1 and input[input.len - 1].indexOf("-") == null then
			lsFolderPath = input[input.len - 1]
		end if
		lsFolder = myComp.File(lsFolderPath)
		if lsFolder == null then
			print("<b>ls: No such file or directory")
		else
			if not lsFolder.has_permission("r") then
				print("<b>ls: permission denied")
			else
				showHide = 0
				if input[0] == "ls" and input.len > 1 and input[1].indexOf("a") != null then
					showHide = 1
				end if
				showDetails = 0
				if input[0] == "ls" and input.len > 1 and input[1].indexOf("l") != null then
					showDetails = 1
				end if
				subFiles = lsFolder.get_folders + lsFolder.get_files
				lsOutput = ""
				for subFile in subFiles
					nameFile = subFile.name
					permission = subFile.permissions
					lsOwner = subFile.owner
					lsSize = subFile.size
					lsGroup = subFile.group
					if showHide or nameFile.indexOf(".") != 0 then
						if lsOutput.len > 0 then
							lsOutput = lsOutput + "\n"
						end if
						if showDetails then
							lsOutput = lsOutput + permission + " " + lsOwner + " " + lsGroup + " " + lsSize + " 00:00 " + nameFile
						else
							lsOutput = lsOutput + nameFile
						end if
					end if	
				end for
				print(format_columns(lsOutput))
			end if
		end if
	end if

// mkdir ==========================================================================================================================
	if input[0] == "mkdir" then cCheck = 1
	if input[0] == "mkdir" and input.len != 2 then print("<b>Usage: mkdir [path/new folder]")
	if input[0] == "mkdir" and input.len == 2 then
		while true
			mdPathFile = input[1]
			mdPathParent = parent_path(mdPathFile)
			mdExistFile = myComp.File(mdPathFile)
			if mdPathParent == mdPathFile then mdPathParent = current_path
			mdParent = myComp.File(mdPathParent)
			if mdParent == null then
				print("<b>mkdir: " + mdPathParent + " not found")
			else if mdExistFile != null then
				print("<b>mkdir: " + mdExistFile.path + " file exists")
			else if not mdParent.has_permission("w") then
				print("<b>mkdir: permission denied")
			else
				mdArrayPath = mdPathFile.split("/")
				mdOutput = myComp.create_folder(mdParent.path,mdArrayPath[mdArrayPath.len - 1])
				if mdOutput != null and mdOutput != 1 then
					print(mdOutput)
				end if
			end if
			break
		end while
	end if

// mkprobe ====================================================================================================================
	if input[0] == "mkprobe" then cCheck = 1
	if input[0] == "mkprobe" and input.len != 1 then print("<b>Usage: mkprobe\ncreates packet for launchprobe")
	if input[0] == "mkprobe" and input.len == 1 then
		probeSrc = "Search = function(input1, obj);if typeof(obj) == ""shell"" then obj = obj.host_computer;file = obj.File(""/"");sList = Memdump(file);info = ""filepath permissions owner group size\n"";for item in sList;if input1 != null then;index = indexOf(item.name, input1);index2 = indexOf(item.path, input1);if typeof(index) == ""number"" or typeof(index2) == ""number"" or item.name == input1 then info = info + item.path + "" "" + item.permissions + "" "" + item.owner + "" "" + item.group + "" "" + item.size + ""\n"";	else if input1 == null then;info = info + item.path + "" "" + item.permissions + "" "" + item.owner + "" "" + item.group + "" "" + item.size + ""\n"";end if;end for;return info;end function;Memdump = function(fileObject);if typeof(fileObject) != ""file"" then return null;newList = [];fileList = fileObject.get_folders + fileObject.get_files;while fileList.len > 0;	file = fileList.pull;if file.is_folder then fileList = fileList + file.get_folders + file.get_files;newList.push(file);	end while;return newList;return true;end function;GetXploit = function(gtw);net_session = metaxploit.net_use(gtw);metalib = net_session.dump_lib;memAddress = metaxploit.scan(metalib);values = [];mems = [];for mem in memAddress;scanResults = metaxploit.scan_address(metalib, mem).split(""Unsafe check: "");for result in scanResults;if result == scanResults[0] then continue;	value = result[result.indexOf(""<b>"")+3:result.indexOf(""</b>"")];obj = metalib.overflow(mem, value);if obj then;continue;else;obj = metalib.overflow(mem, value, gtw);if obj then;globals.mem = mem;globals.value = value;globals.xrouter = gtw;	globals.metalib = metalib;return true;end if;end if;end for;end for;end function;GetSubnets = function(rtr);subnets = rtr.devices_lan_ip;for subnet in subnets;if subnet != ""192.168.1.1"" and subnet != ""192.168.0.1"" then;index = indexOf(subnet,""192.168.1"");index2 = indexOf(subnet,""192.168.0"");if (index == 0  or index2 == 0) and subnet.split(""\."")[2].len < 2 then continue;end if;	globals.subnets.push(subnet);end for;end function;GetSystems = function(gtw);w = gtw.split(""\."")[0];x = gtw.split(""\."")[1];	y = gtw.split(""\."")[2];z = 1;for d in range(1,256);ip = w + ""."" + x +""."" + y + ""."" + z;	globals.systems.push(ip);z = z + 1;end for;end function;metaxploit = include_lib(""/lib/metaxploit.so"");if not metaxploit then metaxploit = include_lib(current_path + ""/metaxploit.so"");if not metaxploit then exit(""<b>probe: metaxploit.so not found"");clear_screen;print(""<b><color=orange>probe</b> by xanadu"");wait(1.5);myComp = get_shell.host_computer;info = ""<b><color=orange>probe</b> by xanadu\n"";metalib = null;xrouter = """";mem = """";xploit = null;systems = [];subnets = [];outputs = [];index = 0;names = [];while true;router = get_router(""192.168.0.1"");if router then;GetSubnets(router);else;router = get_router(""192.168.1.1"");if router then GetSubnets(router);end if;for subnet in subnets;GetSystems(subnet);end for;while subnets.len >= 1;xploit = GetXploit(subnets.pull);if xploit == true then break;end while;if mem and value and metalib then xploit = true;if not xploit then exit(""<b>probe: no exploit found"");if systems and mem and value then;for system in systems;obj = metalib.overflow(mem, value, system);if typeof(obj) == ""computer"" then;if params.len == 1 then;index = index + 1;data = Search(params[0], obj);info = info + ""====================================================================\nsystem public ip: <color=white>"" + obj.public_ip + ""\nsystem lan ip: <color=white>"" + obj.local_ip + ""\nsystem name: <color=yellow>"" + obj.get_name + ""\nsystem processes\n"" + format_columns(obj.show_procs) + ""\n\n"" + format_columns(data) + ""\n"";outputs.push(info);info = ""\n\n\n<b><color=orange>probe</b> by xanadu\n"";if obj.get_name == ""router"" then;	names.push(obj.local_ip);else;names.push(obj.get_name);end if;else if params.len == 0 then;index = index + 1;data = Search(null, obj);info = info + ""====================================================================\nsystem public ip: <color=white>"" + obj.public_ip + ""\nsystem lan ip: <color=white>"" + obj.local_ip + ""\nsystem name: <color=yellow>"" + obj.get_name + ""\nsystem processes\n"" + format_columns(obj.show_procs) + ""\n\n"" + format_columns(data) + ""\n"";outputs.push(info);info = ""\n\n\n<b><color=orange>probe</b> by xanadu\n"";if obj.get_name == ""router"" then;names.push(obj.local_ip);else;names.push(obj.get_name);end if;end if;end if;end for;clear_screen;print(""public ip: <color=white>"" + myComp.public_ip);print(""<b><color=yellow>"" + index + ""</color></b> systems found on Lan\n\n"");folderName = ""package"";mkFolder = null;newFile = null;saveFile = null;print(current_path);mkFolder = myComp.create_folder(current_path, folderName);if mkFolder then newFolder = myComp.File(folderName);if newFolder then;print(""<b>probe: created folder: "" + folderName);else;print(""<b>probe: error: unable to create "" + folderName);end if;end if;showOutput = """";while showOutput != ""y"" and showOutput != ""yes"" and showOutput != ""n"" and showOutput != ""no"";showOutput = user_input(""show outputs?(y/n): "");end while;for output in outputs;if showOutput == ""y"" or showOutput == ""yes"" then clear_screen;if showOutput == ""y"" or showOutput == ""yes"" then print output;if output.len > 80000 then;print(""file character count: <color=white>""+output.len);print(""<b>probe: machine: <color=white><b>""+names.pull);print(""<b>probe: output too big to save to file"");user_input(""press any key to continue"",false,true);else;save = null;fileName = names.pull;touchFile = null;newFile = null;saveFile = null;touchFile = myComp.touch(current_path + ""/"" + folderName + ""/"", fileName);if touchFile then newFile = myComp.File(current_path + ""/"" + folderName + ""/"" + fileName);if newFile then saveFile = newFile.set_content(output);if saveFile then;print(""<b>probe: info saved to file: <b><color=white>"" + fileName);print(""file character count: <color=white>""+output.len);else;print(""<b>probe: error: file not saved"");print(""file character count: ""+output.len);end if;if showOutput ==""y"" or showOutput == ""yes"" then user_input(""press any key to continue"",false,true);end if;end for;break;break;end while;"
		makePacket = myComp.create_folder("/root","packet")
		if makePacket then
			touchProbe = myComp.touch("/root/","probe.txt")
			if touchProbe then
				sourceFile = myComp.File("/root/probe.txt")
				sourceFile.set_content(probeSrc)
				buildProbe = myShell.build("/root/probe.txt", "/root/packet")
				myProbe = myComp.File("/root/packet/probe")
				if myProbe then print("probe successfully compiled in /root/packet")
				sourceFile.delete
				getMeta = myComp.File("/lib/metaxploit.so")
				if getMeta then getMeta.copy("/root/packet", "metaxploit.so")
				checkMeta = myComp.File("/root/packet/metaxploit.so")
				packetFolder = myComp.File("/root/packet")
				if myProbe and checkMeta then packetFolder.chmod("o+x",true)
				if myProbe and checkMeta then print("packet loaded with probe and metaxploit.  ready to launch")
				
			else
				print("<b>mkprobe: failed to create probe source file")
			end if
		else
			print("<b>mkprobe: failed to create packet folder")
		end if
	end if
// mv ===========================================================================================================================
	if input[0] == "mv" then cCheck = 1
	if input[0] == "mv" and input.len != 3 then print("<b>Usage: mv [path/file] [path/opt:new name]")
	if input[0] == "mv" and input.len == 3 then
		while true
			mvOrigFile = input[1]
			mvDestFolder = input[2]
			mvFile = myComp.File(mvOrigFile)
			if mvFile == null then
				print("<b>mv: can't find " + mvOrigFile)
				
			else
				mvNewName = ""
				mvFolder = myComp.File(mvDestFolder)
				if mvFolder == null then
					mvPathParent = parent_path(mvDestFolder)
					if mvPathParent == mvDestFolder then
						mvNewName = mvDestFolder
						mvDestFolder = mvFile.parent.path
						mvFile.move(mvDestFolder,mvNewName)
					else
						mvFolder = myComp.File(mvPathParent)
						mvNewName = mvDestFolder[mvDestFolder.len - (mvDestFolder.len - mvPathParent.len):]
						if mvNewName[0] == "/" then
							mvNewName = mvNewName[1:]
						end if
						if mvFolder == null then
							print("<b>mv: can't copy file. " + mvDestFolder + " doesn't exist.")
							
						end if
					end if
				end if
				if mvFolder != null and mvFolder.parent != null then
					if mvFile.parent.path != mvFolder.parent.path or mvFile.name != mvFolder.name then
						mvFinalDest = mvFolder.path
						if (mvNewName.len == 0) then
							mvNewName = mvFile.name
						end if
						if not mvFolder.is_folder then
							mvFinalDest = mvFile.parent.path
							mvNewName = mvFolder.name
						end if
						if mvFile.parent.path == mvFolder.parent.path and mvNewName != mvFile.name then
							oldFile = mvFile
							mvFile.rename(mvNewName)
						else
							mvFile.move(mvFinalDest,mvNewName)
						end if
					end if		
				else
					check = myComp.File(mvNewName)
					if not check then print("<b>" + input[0] + ": cant find folder " + input[2])
				end if
			end if
			break
		end while
	end if

// nmap ==================================================================================================================
	if input[0] == "nmap" then cCheck = 1
	if (input[0] == "nmap" and (input.len < 2 or input.len > 4)) or (input[0] == "nmap" and input.len == 3 and input[2] != "-i") or (input[0] == "nmap" and input.len == 4 and input[2] != "-i") then print("<b>Usage: nmap [ip address] [opt:-i] [opt:port]")
	if (input[0] == "nmap" and input.len == 2) or (input[0] == "nmap" and input.len == 3 and input[2] == "-i") or (input[0] == "nmap" and input.len == 4 and input[2] == "-i") then
		while true
			if not is_valid_ip(input[1]) then
				print("<b>nmap: invalid ip address")
				break
			end if
			if not myComp.is_network_active then
				print("<b>nmap: No internet access.")
				break
			end if
			nmapIpAddress = input[1]
			nmapIsLanIp = is_lan_ip(nmapIpAddress)
			if nmapIsLanIp then
				nmapRouter = get_router
			else
				nmapRouter = get_router(nmapIpAddress)
			end if
			if nmapRouter == null then
				print("<b>nmap: ip address not found")
				break
			end if
			nmapPorts = null
			if not nmapIsLanIp then
				nmapPorts = nmapRouter.used_ports
			else
				nmapPorts = nmapRouter.device_ports(nmapIpAddress)
			end if
			if nmapPorts == null then
				print("<b>nmap: ip address not found")
				break
			end if
			if typeof(nmapPorts) == "string" then
				print(nmapPorts)
				break
			end if
			nmapInfo = "PORT STATE SERVICE VERSION LAN"
			print("\nStarting nmap at " + current_date)
			print("Interesting ports on " + input[1] + "\n")
			if nmapPorts.len == 0 then
				print("<b>nmap: Scan finished.  No open ports.")
				if input.len == 3 and input[2] == "-i" then RouterData(input[1])
				if input.len == 4 and input[2] == "-i" then RouterData(input[1],input[3])
				break
			end if
			for nPort in nmapPorts
				service_info = nmapRouter.port_info(nPort)
				lan_ips = nPort.get_lan_ip
				port_status = "open"
				if (nPort.is_closed and not nmapIsLanIp) then
					port_status = "closed"
				end if
				nmapInfo = nmapInfo + "\n" + nPort.port_number + " " + port_status + " " + service_info + " " + lan_ips
			end for
			print(format_columns(nmapInfo) + "\n")
			if input.len == 3 and input[2] == "-i" then RouterData(input[1])
			if input.len == 4 and input[2] == "-i" then RouterData(input[1],input[3])
			break
		end while
	end if

// nslookup ==============================================================================================================
	if input[0] == "nslookup" then cCheck = 1
	if input[0] == "nslookup" and input.len != 2 then print("<b>Usage: nslookup [web address]")
	if input[0] == "nslookup" and input.len == 2 then
		while true
			nsAddress = input[1]
			print("<b>nslookup: ip address: " + nslookup(nsAddress))
			break
		end while
	end if
	
// passwd ==============================================================================================================
	if input[0] == "passwd" then cCheck = 1
	if input[0] == "passwd" and input.len != 2 then print("<b>Usage: passwd [username]")
	if input[0] == "passwd" and input.len == 2 then
		while true	
			inputPass = user_input("Changing password for user " + input[1] + ".\nNew password:", true)
			passOutput = myComp.change_password(input[1], inputPass)
			if passOutput == true then
				print("<b>passwd: password modified OK")
				break
			else if output then
				print(output)
			end if
			break
		end while
	end if

// ping =============================================================================================================
	if input[0] == "ping" then cCheck = 1
	if input[0] == "ping" and input.len != 2 then print("<b>Usage: ping [ip address]")
	if input[0] == "ping" and input.len == 2 then
		while true
			pResult = myShell.ping(input[1])
			if pResult then
				if typeof(pResult) == "string" then
					print(pResult)
				else
					print("<b>ping: Ping successful")
				end if
			else
				print("<b>ping: ip unreachable")
			end if
			break
		end while
	end if

// ps =============================================================================================================
	if input[0] == "ps" then cCheck = 1
	if input[0] == "ps" and input.len != 1 then print("<b>Usage: ps")
	if input[0] == "ps" and input.len == 1 then print myComp.show_procs

// pwd ================================================================================================================
	if input[0] == "pwd" then cCheck = 1
	if input[0] == "pwd" and input.len != 1 then print("<b>Usage: pwd")
	if input[0] == "pwd" and input.len == 1 then print(current_path)

// quit =====================================================================================================
	if input[0] == "quit" then cCheck = 1
	if input[0] == "quit" and input.len != 1 then print("<b>Usage: quit")
	if input[0] == "quit" then exit
	
// rcat ============================================================================================================
	if input[0] == "rcat" then cCheck = 1
	if input[0] == "rcat" and input.len != 2 then print("<b>Usage: rcat [file]")
	if (input[0] == "rcat" and input.len == 2)then
		if object and (typeof(object) == "shell" or typeof(object) == "computer") then
			CAT(input[0], object, input[1])
		else
			print("<b>rcat: not holding remote shell or computer object")
		end if
	end if
		
// rcorlog ========================================================================================================
	if input[0] == "rcorlog" then cCheck = 1
	if input[0] == "rcorlog" and input.len != 1 then print("<b>Usage: rcorlog")
	if input[0] == "rcorlog" and input.len == 1 then
		if object and (typeof(object) == "shell" or typeof(object) == "computer") then
			rlogSure = null
			while rlogSure != "y" and rlogSure != "yes" and rlogSure != "n" and rlogSure != "no"
				rlogSure = user_input("corrupt system.log?(y/n): ")
			end while
			if rlogSure == "y" or rlogSure == "yes" then CORRUPTLOG(input[0], object)
			rlogSure = null
		else
			print("<b>rcorlog: not holding remote shell or computer object")
		end if
	end if

// rcp ==============================================================================================================
	if input[0] == "rcp" then cCheck = 1
	if input[0] == "rcp" and input.len != 3 then print("<b>Usage: rcp [path to file] [path to copy]")
	if input[0] == "rcp" and not object and input.len == 3 then print("<b>rcp: not holding remote shell or computer object")
	if input[0] == "rcp" and object and input.len == 3 then COPY(input[0], input[1], input[2], object)

// rdecipher =========================================================================================================
	if input[0] == "rdecipher" then cCheck = 1
	if input[0] == "rdecipher" and input.len == 3 and (input[1] == "-h" or input[1] == "-f") and object then
		DECIPHER(input[0], input[1], input[2], object)
	else if input[0] == "rdecipher" and input.len == 3 and (input[1] == "-h" or input[1] == "-f") and not object then
		print("<b>rdecipher: not holding remote shell or computer object")
	else if input[0] == "rdecipher" then 
		print("<b>usage: rdecipher -h [hash]\n<b>Usage: rdecipher -f [path/file]")
	end if
// rkill ============================================================================================================
	if input[0] == "rkill" then cCheck = 1
	if input[0] == "rkill" and input.len != 2 then print("<b>Usage: rkill [PID]")
	if input[0] == "rkill" and input.len == 2 then	
		if object and (typeof(object) == "shell" or typeof(object) == "computer") then
			KILL(input[0], input[1], object)
		else
			print("<b>rkill: not holding remote shell or computer object")
		end if
	end if
		
// rm =================================================================================================================
	if input[0] == "rm" then cCheck = 1
	if (input[0] == "rm" and input.len < 2) or (input[0] == "del" and input.len > 3) or (input[0] == "rm" and input.len == 3 and input[1] != "-r") then print("<b>Usage: </b>rm [opt:-r] [path/file]")
	if (input[0] == "rm" and input.len == 2) then RM(input[0], input[1], null, myComp)
	if (input[0] == "rm" and input.len == 3 and input[1] == "-r") then RM(input[0], input[1], input[2], myComp)

// rps ============================================================================================================
	if input[0] == "rps" then cCheck = 1
	if input[0] == "rps" and input.len != 1 then print("<b>Usage: rps")
	if input[0] == "rps" and input.len == 1 then
		if object and (typeof(object) == "shell" or typeof(object) == "computer") then
			if typeof(object) == "shell" then print object.host_computer.show_procs
			if typeof(object) == "computer" then print object.show_procs	
		else
			print("<b>rps: not holding remote shell or computer object")
		end if
	end if

// rrm ============================================================================================================
	if input[0] == "rrm" then cCheck = 1
	if input[0] == "rrm" then
		while true
			if (input[0] == "rrm" and input.len < 2) or (input[0] == "rrm" and input.len > 3) or (input[0] == "rrm" and input.len == 3 and input[1] != "-r") then
				print("<b>Usage: rrm [opt:-r] [path/file]")
				break
			end if
			if (input[0] == "rrm" and object and (typeof(object) == "shell" or typeof(object) == "computer")) then
				if (input[0] == "rrm" and input.len == 2) then RM(input[0], input[1], null, object)
				if (input[0] == "rrm" and input.len == 3 and input[1] == "-r") then RM(input[0], input[1], input[2], object)
			else
				print("<b>rrm: not holding remote shell or computer object")
			end if
			break
		end while
	end if

// rsearch ========================================================================================================
	if input[0] == "rsearch" then cCheck = 1
	if input[0] == "rsearch" and input.len > 2 then print("<b>Usage: rsearch [opt:file]")
	if (input[0] == "rsearch" and not object and input.len < 3) then print("<b>rsearch: not holding remote shell or computer object")
	if input[0] == "rsearch" and object and input.len == 1 then SEARCH(null, object)
	if input[0] == "rsearch" and object and input.len == 2 then SEARCH(input[1], object)

// rterminal ==================================================================================================
	if input[0] == "rterminal" then cCheck = 1
	if input[0] == "rterminal" and input.len != 1 then print("<b>Usage: rterminal")
	if input[0] == "rterminal" and input.len == 1 and typeof(object) != "shell" then print("<b>rterminal: not holding remote shell object")
	if input[0] == "rterminal" and input.len == 1 and typeof(object) == "shell" then TERMINAL(input[0], object)
// rtouch =====================================================================================================
	if input[0] == "rtouch" then cCheck = 1
	if input[0] == "rtouch" and input.len != 2 then print("<b>Usage: rtouch [path/new file]")
	if (input[0] == "rtouch" and input.len == 2) and (typeof(object) !=  "shell" and typeof(object) and "computer" and typeof(object) == "file") then print("</b>rtouch: not holding remote shell or computer object")
	if input[0] == "rtouch" and input.len == 2 and (typeof(object) == "shell" or typeof(object) == "computer") then TOUCH(input[0], input[1], object)

// scan ========================================================================================================
	if input[0] == "scan" then cCheck = 1
	if input[0] == "scan" and input.len != 3 then print("<b>Usage: scan [ip address] [port number]\n<b>Usage: scan -l [path to lib]")
	if input[0] == "scan" and input.len == 3 then SCAN(input[0], input[1], input[2], myComp)

// search ====================================================================================================
	if input[0] == "search" then cCheck = 1
	if input[0] == "search" and input.len > 2 then print("<b>Usage: search [opt:file]")
	if input[0] == "search" and input.len == 2 then SEARCH(input[1], myComp)
	if input[0] == "search" and input.len == 1 then SEARCH(null, myComp)

// secure ======================================================================================
	if input[0] == "secure" then cCheck = 1
	if input[0] == "secure" and input.len > 1 then print("<b>Usage: security\n<color=red>WARNING: secure will make major changes to your system!!!")
	if input[0] == "secure" and input.len == 1 then SECURE
// ssh ==============================================================================================
	if input[0] == "ssh" then cCheck = 1
	if input[0] == "ssh" and (input.len < 3 or input.len > 4) then print("<b>Usage: ssh [user@password] [ip address] [opt:port]")
	if input[0] == "ssh" and (input.len == 3 or input.len == 4) then
		while true
			sshCredentials = input[1].split("@")
			sshUser = sshCredentials[0]
			sshPassword = sshCredentials[1]
			sshPort = 22
			if input.len == 4 then sshPort = input[3].to_int
			if typeof(sshPort) != "number" then
				print("<b>ssh: Invalid port: " + sshPort)
				break
			end if
			print("Connecting...")			
			sshShell = get_shell.connect_service(input[2],sshPort,sshUser,sshPassword,"ssh")
			if typeof(sshShell) == "string" then
				print(sshShell)
				break
			end if			
			if sshShell then 
				sshShell.start_terminal
			else 
				print("<b>ssh: connection failed")
			end if			
			break
		end while
	end if

// sudo =============================================================================================
	if input[0] == "sudo" then cCheck = 1
	if (input[0] == "sudo" and input.len == 1) or (input[0] == "sudo" and input[1] == "-u" and input.len != 3) or (input[0] == "sudo" and input[1] == "-s" and input.len != 2) then
		print("<b>Usage: sudo [binaryfile]\n<b>Usage: sudo [-u] [user]\n<b>Usage: sudo [-s]")
	else if (input[0] == "sudo" and input.len >= 2) or (input[0] == "sudo" and input[1] == "-u" and input.len == 3) or (input[0] == "sudo" and input[1] == "-s" and input.len == 2) then
		while true
			inputPass = user_input("Password: ",true)
			if input[1] == "-u" then
				sShell = get_shell(input[2],inputPass)
				if not sShell then
					print("<b>sudo: incorrect username or password")
					break
				end if
			else
				sShell = get_shell("root",inputPass)
				if not sShell then
					print("<b>sudo: incorrect password")
					break
				end if
			end if	
			if input[1] == "-s" or input[1] == "-u" then
				sShell.start_terminal
			else
				args = input[2:].join(" ")
				if not input[1].indexOf("/") then
					globalPath = [current_path,"/bin","/usr/bin"]
					for spath in globalPath
						program = myComp.File(spath + "/" + input[1])
						if program != null then
							sShell.launch(program.path,args)
							exit
						end if
					end for
				else
					program = myComp.File(input[1])
					if not program then
						print("sudo: " + input[1] + " not found")
						break
					end if
					sShell.launch(program.path,args)
				end if
			end if
			break
		end while
	end if

// terminal =================================================================================================================
	if input[0] == "terminal" then cCheck = 1
	if input[0] == "terminal" and input.len != 1 then print("Usage: terminal")
	if input[0] == "terminal" and input.len == 1 then
		termSure = null
		while termSure != "y" and termSure != "yes" and termSure != "n" and termSure != "no"
			termSure = user_input("open new terminal?(y/n): ")
		end while
		if termSure == "y" or termSure == "yes" then myShell.start_terminal
		termSure = null
	end if
// title =======================================================================================================================
	if input[0] == "title" then cCheck = 1
	if input[0] == "title" and input.len != 1 then print("<b>Usage: title")
	if input[0] == "title" and input.len == 1 then title()

// touch =========================================================================================================================
	if input[0] == "touch" then cCheck = 1
	if input[0] == "touch" and input.len != 2 then print("<b>Usage: touch [path/new file]")
	if input[0] == "touch" and input.len == 2 then TOUCH(input[0], input[1], myComp)
		
// useradd =====================================================================================================================
	if input[0] == "useradd" then cCheck = 1
	if input[0] == "useradd" and input.len != 2 then print("<b>Usage: useradd [new username]")
	if input[0] == "useradd" and input.len == 2 then
		while true
			inputMsg = "Setting password for user " + input[1] + ".\nNew password: "
			inputPass = user_input(inputMsg,true)
			uaOutput = myComp.create_user(input[1],inputPass)
			if uaOutput == true then
				print("<b>useradd: User created OK")
				break
			end if
			if uaOutput then
				print(uaOutput)
				break
			end if
			print("<b>useradd: the user could not be created.")
			break
		end while
	end if

// userdel ===================================================================================================
	if input[0] == "userdel" then cCheck = 1
	if (input[0] == "userdel" and input.len == 1) or (input[0] == "userdel" and input.len == 2 and input[1] == "-r") or (input[0] == "userdel" and input.len > 3) or (input[0] == "userdel" and input.len == 3 and input[1] != "-r") then print("<b>Usage: userdel [opt:-r] [username]\n<b>Use paremeter -r to delete user files too.")
	if (input[0] == "userdel" and (input.len == 2 and input[1] != "-r")) or (input[0] == "userdel" and input.len == 3 and input[1] == "-r") then 
		while true
			userDelete = 0
			if input[1] == "-r" then
				userDelete = 1
				input.pull
			end if
			userDeleteOutput = myComp.delete_user(input[1], userDelete)
			if userDeleteOutput == true then
				print("<b>userdel: user " + input[1] + " deleted.")
				break
			end if
			if userDeleteOutput then
				print(userDeleteOutput)
				break
			end if
			print("<b>userdel: user not deleted.")
			break
		end while
	end if
// whoami ====================================================================================================================================
	if input[0] == "whoami" then cCheck = 1
	if input[0] == "whoami" and input.len != 1 then print("<b>Usage: whoami")
	if input[0] == "whoami" and input.len == 1 then print(active_user)
		
// whois ========================================================================================================================
	if input[0] == "whois" then cCheck = 1
	if input[0] == "whois" and input.len != 2 then print("<b>Usage: whois [public IP address]")
	if input[0] == "whois" and input.len == 2 then
		whoAddress = input[1]
		print(whois(whoAddress))
	end if

// help ===========================================================================================================================================
	if input[0] == "help" then cCheck = 1
	if input[0] == "help" and input.len != 2 then print("<b>Usage: help -a for all commands\n<b>Usage: help -l for local system commands\n<b>Usage: help -n for network commands\n<b>Usage: help -h for hacking commands\n<b>Usage: help -r for remote system commands\n<b>launch binary files with ./[binary file] + parameters")
	if input[0] == "help" and input.len == 2 and (input[1] == "-l" or input[1] == "-a") then
		
		print("<color=green><b>-------------------- Local system commands ------------------------------------</b></color>")
		print("<color=yellow><b>aircrack</b> ---> Usage: aircrack [file.cap]")
		print("<color=yellow><b>aireplay</b> ---> Usage: aireplay [bssid] [essid] [max ack's]")
		print("<color=yellow><b>airmon</b> -----> Usage: airmon\n               <color=yellow>Usage: airmon [start:stop] [Net Device]")
		print("<color=yellow><b>apt-get</b> ----> Usage: apt-get install [program name]\n               <color=yellow>Usage: apt-get search [program name]\n               <color=yellow>Usage: apt-get show [repo ip address]\n               <color=yellow>Usage: apt-get addrepo [repo ip address]\n               <color=yellow>Usage: apt-get delrepo [repo ip address]\n               <color=yellow>Usage: apt-get update\n               <color=yellow>Usage: apt-get upgrade")		
		print("<color=yellow><b>build</b> ------> Usage: build [file source code] [path/program name]")
		print("<color=yellow><b>cat</b> --------> Usage: cat [file]")
		print("<color=yellow><b>chgrp</b> ------> Usage: chgrp [opt:-R] [new group] [path file/folder]")
		print("<color=yellow><b>chmod</b> ------> Usage: chmod [opt:-R] [u,g,o+wrx] [path file/folder]")
		print("<color=yellow><b>chown</b> ------> Usage: chown [opt:-R] [owner] [path file/folder]")
		print("<color=yellow><b>clean</b> ------> Usage: clean\n               <color=orange>empty /root/.Trash")
		print("<color=yellow><b>clear</b> ------> Usage: clear")
		print("<color=yellow><b>corlog</b> -----> Usage: corlog\n               <color=orange>corrupt local system.log!!!")
		print("<color=yellow><b>cp</b> ---------> Usage: cp [path/original file] [path/opt:new name]")
		print("<color=yellow><b>credits</b> ----> Usage: credits")
		print("<color=yellow><b>decipher</b> ---> Usage: decipher -h [hash]\n               <color=yellow>Usage: decipher -f [path/file]")
		print("<color=yellow><b>exit</b> -------> Usage: exit")
		print("<color=yellow><b>groupdel</b> ---> Usage: groupdel [user] [group]")
		print("<color=yellow><b>groupadd</b> ---> Usage: groupadd [user] [new group]")
		print("<color=yellow><b>groups</b> -----> Usage: groups [username]")
		print("<color=yellow><b>ifconfig</b> ---> Usage: ifconfig \n               <color=yellow>Usage: ifconfig [net interface] [ip address] gateway [ip address]</color>")
		print("<color=yellow><b>iwconfig</b> ---> Usage: iwconfig [net device] [bssid] [essid] [password]")
		print("<color=yellow><b>iwlist</b> -----> Usage: iwlist [net device]")
		print("<color=yellow><b>kill</b> -------> Usage: kill [PID]")
		print("<color=yellow><b>ls</b> ---------> Usage: ls [opt:-l, -a, -la, -al] [opt:path]")
		print("<color=yellow><b>mkdir</b> ------> Usage: mkdir [path/new folder]")
		print("<color=yellow><b>mv</b> ---------> Usage: mv [path/file] [path/opt:new name]")
		print("<color=yellow><b>passwd</b> -----> Usage: passwd [username]")
		print("<color=yellow><b>ps</b> ---------> Usage: ps")
		print("<color=yellow><b>pwd</b> --------> Usage: pwd")
		print("<color=yellow><b>quit</b> -------> Usage: quit")
		print("<color=yellow><b>rm</b> ---------> Usage: rm [opt:-r] [path/file]")
		print("<color=yellow><b>search</b> -----> Usage: search [opt:filename]")
		print("<color=yellow><b>secure</b> -----> Usage: secure\n               <color=orange>must have current xtools in /root\n               <color=orange>use on home system only!\n               <color=orange>secures machine and makes xtools the only way to access system\n               <color=red>WARNING: secure makes major changes to your system!!!\n               <color=red>WARNING: only for hardcore xtools users")
		print("<color=yellow><b>sudo</b> -------> Usage: sudo [binaryfile]\n               <color=yellow>Usage: sudo [-u] [user]</color>\n               <color=yellow>Usage: sudo [-s]</color>")
		print("<color=yellow><b>terminal</b> ---> Usage: terminal\n               <color=orange>open new terminal on local system\n               <color=red>warning: will close xtools!")
		print("<color=yellow><b>title</b> ------> Usage: title")
		print("<color=yellow><b>touch</b> ------> Usage: touch [path/filename]")
		print("<color=yellow><b>useradd</b> ----> Usage: useradd [new username]")
		print("<color=yellow><b>userdel</b> ----> Usage: userdel [opt:-r] [username]\n               <color=orange>Use paremeter -r to delete user files too.")
		print("<color=yellow><b>whoami</b> -----> Usage: whoami")		
	end if
	if input[0] == "help" and input.len == 2 and (input[1] == "-n" or input[1] == "-a") then
		print("\n<color=green><b>---------------------- Network commands -------------------------------------</b></color>")
		print("<color=yellow><b>ftp</b> --------> Usage: ftp [user@password] [ip address]")	
		print("<color=yellow><b>nmap</b> -------> Usage: nmap [ip address] [opt:-i] [opt:port]\n               <color=orange>opt [-i] maps network, leaves logs")
		print("<color=yellow><b>nslookup</b> ---> Usage: nslookup [web address]")	
		print("<color=yellow><b>ping</b> -------> Usage: ping [ip address]")
		print("<color=yellow><b>ssh</b> --------> Usage: ssh [user@password] [ip address] [opt:port]")
		print("<color=yellow><b>whois</b> ------> Usage: whois [public IP address]")
	end if
	if input[0] == "help" and input.len == 2 and (input[1] == "-h" or input[1] == "-a") then
		print("\n<color=green><b>---------------------- Hacking commands -------------------------------------</b></color>")
		print("<color=yellow><b>bankscrape</b> -> Usage: bankscrape [ip address] [# of accounts] [output file name]\n               <color=orange>will append to already existing output file\n               <color=yellow>Usage: bankscrape -l [output file]\n               <color=orange>use -l to display and then remove bank creds from list.")
		print("<color=yellow><b>drop</b> -------> Usage: drop [-r:-l]\n              <color=orange> -r drops held remote object!!!\n               <color=orange>-l drops held local object!!!")
		print("<color=yellow><b>escalate</b> ---> Usage: escalate\n               <color=orange>attempt to escalate privileges on local system")
		print("<color=yellow><b>grab</b> -------> Usage: grab [ip address] [port number] [memory address] [usecure value] [opt:arg]\n               <color=yellow>Usage: grab -l [libname] [memory address] [usecure value] [opt:arg]\n               <color=orange>grabs object!!!\n               <color=orange>use optional argument for change password or bounce to lan address")
		print("<color=yellow><b>launchprobe</b>-> Usage: launchprobe [ipaddress] [opt: -r] [opt: search term]\n               "+color.yellow+"if you run into any data dumps that are too \n               "+color.yellow+"big to save use optional search term argument\n               "+color.yellow+"use optional -r to launch at router_kernel")
		print("<color=yellow><b>mkprobe</b> ----> Usage: mkprobe\n               <color=yellow>creates packet for launchprobe")
		print("<color=yellow><b>scan</b> -------> Usage: scan [ip address] [port number]\n               <color=orange>scanning a remote system will leave logs on target system!!!\n               <color=yellow>Usage:scan -l [path/libfile]")
	end if
	if input[0] == "help" and input.len == 2 and (input[1] == "-r" or input[1] == "-a") then
		print("\n<color=green><b>-----------------------Remote system commands -------------------------------</b></color>")
		print("<color=yellow><b>rcat</b> -------> Usage: rcat [file]")
		print("<color=yellow><b>rcorlog</b> ----> Usage: rcorlog\n               <color=orange>corrupt remote machine's system.log")
		print("<color=yellow><b>rcp</b> --------> Usage: rcp [path/file] [path/opt:new name]")
		print("<color=yellow><b>rdecipher</b>---> Usage: rdecipher -h [hash]\n               <color=yellow>Usage: decipher -f [path/file]")
		print("<color=yellow><b>rkill</b> ------> Usage: rkill [PID]")
		print("<color=yellow><b>rps</b> --------> Usage: rps")
		print("<color=yellow><b>rrm</b> --------> Usage: rrm [opt:-r] [path/file]")
		print("<color=yellow><b>rsearch</b> ----> Usage: rsearch [opt:file]")
		print("<color=yellow><b>rterminal</b> --> Usage: rterminal")
		print("<color=yellow><b>rtouch</b> -----> Usage: rtouch [path/new File]")
	end if
	if input[0] == "" then cCheck = 1
	if cCheck == 0 then print("<b>xtools: " + input[0] + ": command not found") 
end while

// access code fail case =========================================================================================================================
denied = "<b>ah ah ah you didnt say the magic word ah ah ah</b>"
while true 
	print "<color=red>" + denied + "</color>"
	print "<color=orange>" + denied + "</color>"
	print "<color=yellow>" + denied + "</color>"
	print "<color=green>" + denied + "</color>"
	print "<color=blue>" + denied + "</color>"
	print "<color=purple>" + denied + "</color>"
end while
